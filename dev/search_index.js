var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = ACEfit","category":"page"},{"location":"#ACEfit","page":"Home","title":"ACEfit","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ACEfit.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ACEfit]","category":"page"},{"location":"#ACEfit.Dat","page":"Home","title":"ACEfit.Dat","text":"Dat: store one configuration (input, e.g., structure, state, ...)  that can  have multiple observations attached to it. Fields:\n\nconfig::Any : the structure \nconfigtype::String : Each dat::Dat belongs to a group identified by a string dat.configtype to allow filtering, and grouping. \nobs::Vector{Any}  : list of observations \nmeta::Dict{String, Any} : any additional meta information that we may want to attach to this data point; this needs to be raw json.\n\n\n\n\n\n","category":"type"},{"location":"#ACEfit.devec_obs","page":"Home","title":"ACEfit.devec_obs","text":"convert a Vector{T} to some real data, e.g.,\n\nx::Vector{Float64}\ndevec_obs(::Type{ObsVirial}, x) = [ x[1] x[2] x[3]; \n                                    x[2] x[4] x[5];\n                                    x[3] x[5] x[6] ]\n\n\n\n\n\n","category":"function"},{"location":"#ACEfit.eval_obs","page":"Home","title":"ACEfit.eval_obs","text":"Evaluate a specific observation type: Given an observation obs,  a model model and  a configuration cfg = dat.config, the call \n\neval_obs(obs, model, cfg)\n\nmust return the corresponding observation. For example, if  obs::ObsPotentialEnergy and cfg = at::Atoms, and model is an interatomic  potential, then \n\neval_obs(obs::ObsPotentialEnergy, model, cfg) = \n      ObsPotentialEnergy( energy(model, cfg) )\n\n\n\n\n\n","category":"function"},{"location":"#ACEfit.titerate-Tuple{Any, Any}","page":"Home","title":"ACEfit.titerate","text":"titerate(f, data; kwargs...) Multi-threaded map loop. At each iteration the function f(dat) is executed, where dat in data. The order is not necessarily preserved. In fact the  costs array is used to sort the data by decreasing cost to ensure the  most costly configurations are encountered first. This helps avoid threads  without work at the end of the loop.\n\n\n\n\n\n","category":"method"},{"location":"#ACEfit.vec_obs","page":"Home","title":"ACEfit.vec_obs","text":"convert some real data, in some generic format, into a vector to be stored in a Dat or Lsq system. E.g.,\n\nV = virial(...)::Matrix{Float64}\nobsV = ObsVirial(V)\nvec_obs(obsV::ObsVirial) = obsV.V[ [1,2,3,5,6,9] ]  # NB: V is symmetric\n\n\n\n\n\n","category":"function"}]
}
